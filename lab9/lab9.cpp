#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 1;
int a[N];
int n;
void read(){
    cin >> n; // Вводим длину массива
    for (int i = 1; i <= n; i++){
        cin >> a[i]; // Сам массив вводим
    }
}
long long p[N]; // Массив префиксных сумм
void solver(){
    for (int i = 1; i <= n; i++){
        p[i] = p[i - 1] + a[i]; // Считаем префиксные суммы
    }
    map <long long, int> last; // Таблица для того, чтобы быстро узнавать где последний раз видели такую же префиксную сумму
    last[0] = 0; // Необходимо сделать так как мы могли не рассмотреть ничего и соответственно сумма равно 0
    int lastI = 0; // Предыдущая позиция i для j, такой что [i, j] является разумным
    long long ans = 0; // Храним ответ
    for (int j = 1; j <= n; j++){
        if (last.count(p[j]) == 0){ // Если такой префикс не встречался раньше
            last[p[j]] = j; // Запомним, что префиксная сумма p[j] последний раз встречалась на позиции j.
            continue;
        }
        int i = last[p[j]] + 1; // Так как мы нашли, такой i, что p[j] = p[i], тогда a[i + 1], a[i + 2], ... + a[j] = 0
        long long cntL = (i - lastI); // Количество вариантов выбрать l для нормального подотрезка
        long long cntR = (n - j + 1); // Количество способов выбрать r для нормального подотрезка
        ans += cntL * cntR; // Количество способов выбрать l, r.
        lastI = i;
        last[p[j]] = j;
    }
    cout << ans << endl;

}

void solve(){
    read(); // Функция ввода
    solver(); // Функция где решается задача
}

int main(){
    ios::sync_with_stdio(NULL), cin.tie(0), cout.tie(0); // Оптимизирует ввод
    solve();
}
